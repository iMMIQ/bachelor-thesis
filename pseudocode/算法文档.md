# 算法文档

## 输入和输出

> 输入：三维障碍物信息，起点和终点

> 输出：布线信息

## 总步骤

1. 将输入的三维障碍物表面转换为若干矩形。

2. 在这些矩形内随机生成稀疏的点，连接相邻矩阵内的点形成边集，计算最短路径，记录路径经过的矩形。

3. 将矩形依据重叠的边是否平行，分为若干组矩形集。这些集合交界的垂直的边上取一个点，作为路径的中间点，通过 ~~Nelder-Mead算法~~ 模拟退火优化出最优点的位置集合。

4. 对于每组矩形集，计算第三步得到的点之间的最短路径。

## 算法1

### 步骤

1. 将输入的三维障碍物转换为包含三角面的.stl文件，再解析成若干个三角面。

2. 如果相邻三角面可以组成一个矩形，则将它们拼接成一个矩形，否则近似分割成网格。

3. 对于距离较近且有边平行的矩形，将较小的矩形拉伸到与另一个矩形相邻。

## 算法2

### 步骤

1. 在每个矩形内，根据矩形的大小生成若干个随机点。
   
   ```
   FOR_EACH r in rectangles:
       n := ceil(n / SIZE)
       FOR i in [0, n):
           x := rand(0, 1)
           y := rand(0, 1)
           // LR表示右下点，LL表示左下点, UR表示右上点
           point := (r.LL - r.LR) * x + (r.UR - r.LR) * y + r.LR
           pointset.add(point)
   ```

2. 将起点、终点和前一步得到的点集看作一个图，在相邻矩阵内的点之间连接边。在这个图上通过Dijkstra算法找到最短路径，记录路径经过的矩形集合。

## 算法3

### 步骤

1. 如果一组矩形中相邻的矩形之间存在平行的重叠边，则将它们归为同一组矩形集。

2. 不同的矩形集之间，它们之间重叠的边上即为路径中间点的位置。

3. 基于模拟退火算法，使用算法4计算两个中间点之间的最短路径，通过优化来确保路径长度最小化。

## 算法4

### 步骤

1. 将三维障碍物的表面转换为一系列矩形，然后将这些矩形映射到一个平面上。在这个平面上，起点和终点也被映射为二维坐标。这一步可以通过几何变换来完成，具体的操作包括旋转、平移等。

2. 对于这个平面上的矩形集，使用动态规划算法计算出从起点到终点的最短路径。这个算法可以在较短的时间内求解出所有矩形内的最短路径。

3. 将第一步中得到的映射结果，再通过几何变换的逆操作，将矩形集还原为三维空间中的矩形。这样就得到了最短路径的具体布线信息。

### 算法4.1：矩形集几何变换

> 输入：矩形集，每个矩形由三个空间顶点的坐标定义

> 输出：矩形集，每个矩形由左下和右上两个平面点坐标定义

#### 步骤

1. 将整个矩形集进行平移，使得一个矩形的顶点位于原点。

2. 将整个矩形集绕x轴旋转，使得所有矩形的底边与y轴垂直。

3. 继续绕y轴旋转，使得这个矩形的底边在x轴上。

4. 继续绕x轴旋转，使得这个矩形的顶边在x-y平面上。这样这个矩形就被映射到了一个平面上。

5. 将这个矩形从矩形集中移除，并将这个矩形的映射结果加入到一个新的矩形集中。重复步骤1到步骤4，直到所有的矩形都被映射为平面上的矩形。

##### 算法4.1.1

```
move := r0.LL

FOR r in set

    FOR p in [r.LL, r.LR, r.UR]

        p := p - move
```

##### 算法4.1.2

若要将空间点绕x轴旋转$\theta$度，则其旋转后的坐标为

$ \begin{bmatrix}
 x' & y' & z' & 1
\end{bmatrix} = \begin{bmatrix}
 x & y & z & 1
\end{bmatrix}\begin{bmatrix}
 1 & 0 & 0 & 0\\
 0 & \cos \theta & \sin \theta & 0\\
 0 & -\sin \theta & \cos \theta & 0\\
 0 & 0 & 0 & 1
\end{bmatrix} $

$x' = x$

$y' = y \cos \theta - z \sin \theta$

$z' = y \sin \theta + z \cos \theta$

因此，首先需要求解$\theta$使得$y'_{右下顶点} = y \cos \theta - z \sin \theta = y_{左下顶点}$

对于方程$a \cos \theta - b \sin \theta = c$

$\theta$的一组解为：

$x=\begin{cases}
2 \tan ^ {-1} \frac{\sqrt{a^2+b^2-c^2}-b}{a + c} \text{ if } a \ne c \And a^2 + ac + b^2 \ne b \sqrt{a^2+b^2-c^2} \\
2 \tan ^ {-1} \frac{-\sqrt{a^2+b^2-c^2}-b}{a + c} \text{ if } a \ne c \And a^2 + ac + b^2 + b \sqrt{a^2+b^2-c^2} \ne 0 \\
2 \tan ^ {-1} \frac{a}{b} \text{ if } b \ne 0 \And a + c =0
\end{cases}$

将得到的$\theta$值代入上述旋转公式，即可旋转整个矩形集上的关键点。具体实现代码如下：

```
r0 := set.first //获取矩形集的第一个关键点

// LR表示右下点，LL表示左下点, UR表示右上点

theta := solve(r0.LR.y, r0.LR.z, r0.LL.y) // 求解theta

FOR_EACH r in set: rotate around the x-axis(theta) // 旋转整个矩形集上的关键点
```

##### 算法4.1.3

对于空间点绕y轴旋转$\theta$ °，旋转后坐标为

$\begin{bmatrix}
 x' & y' & z' & 1
\end{bmatrix} = \begin{bmatrix}
 x & y & z & 1
\end{bmatrix}\begin{bmatrix}
 \cos \theta & 0 & -\sin \theta & 0\\
 0 & 1 & 0 & 0\\
 \sin \theta & 0 & \cos \theta & 0\\
 0 & 0 & 0 & 1
\end{bmatrix}$

$x' = z \sin \theta + x \cos \theta$

$y' = y$

$z' = z \cos \theta - x \sin \theta$

由于此时矩形左下点在原点，底边与y轴垂直，因此此时绕y轴旋转一定角度，可以使得底边与x轴重合，角度$\theta$满足$z' = z \cos \theta - x \sin \theta = 0$，$\theta = \tan^{-1}\frac{z}{x}$，这里的$[x\ y\ z]$来自r0.LR

##### 算法4.1.4

此时，矩形底边与x轴重合，只需绕x轴旋转，使r0.UR.z=0，则满足矩形存在三个顶点在x-y平面上，矩形即在x-y平面上。

$z' = y \sin \theta + z \cos \theta = 0$

$\theta = - \tan^{-1} \frac{z}{y}$

这里的$[x\ y\ z]$来自r0.UR

#### 算法4.2：映射点

> 输入：点x，矩形r0，映射矩形r0'

> 输出：映射点x'

若令

$\vec{A} = r0.LL - r0.LR$

$\vec{B} = r0.UR - r0.LR$

$\vec{C} = x - r0.LR$

则有：$\vec{C} = a \cdot \vec{A} + b \cdot \vec{B}$

解得：

$a = \begin{cases}
\frac{C_xB_y-B_xC_y}{A_xB_y-B_xA_y} \text{ if } A_xB_y \ne B_xA_y \\
\frac{C_yB_z-B_yC_z}{A_yB_z-B_yA_z} \text{ if } A_yB_z \ne B_yA_z \\
\frac{C_xB_z-B_xC_z}{A_xB_z-B_xA_z} \text{ if } A_xB_z \ne B_xA_z
\end{cases}$

$b = \begin{cases}
\frac{A_xC_y-C_xA_y}{A_xB_y-B_xA_y} \text{ if } A_xB_y \ne B_xA_y \\
\frac{A_yC_z-C_yA_z}{A_yB_z-B_yA_z} \text{ if } A_yB_z \ne B_yA_z \\
\frac{A_xC_z-C_xA_z}{A_xB_z-B_xA_z} \text{ if } A_xB_z \ne B_xA_z
\end{cases}$

这里的 a 和 b 表示点 x 在矩形 r0 中相对于三个顶点的位置。因此，可以    将点 x 映射为：

$x' = r0'.LR + a \cdot \vec{A'} + b \cdot \vec{B'}$

#### 算法4.3：求解二维平面内单向矩形集内最短路径

定义$dp_{i,0}$为从第$i$个矩形交界线的最低点出发，到达下一个矩形交界线的最低点的最短路径长度；$dp_{i,1}$为从第$i$个矩形交界线的最高点出发，到达下一个矩形交界线的最高点的最短路径长度。则状态转移方程为：

$dp_{i, 0} = \begin{cases}
\min(dp_{j, 0}, dp_{i, 0} + dis(LOW_i, LOW_j)) \\
\min(dp_{j, 1}, dp_{i, 0} + dis(LOW_i, HIGH_j))
\end{cases}$

$dp_{i, 1} = \begin{cases}
\min(dp_{j, 0}, dp_{i, 1} + dis(HIGH_i, LOW_j)) \\
\min(dp_{j, 1}, dp_{i, 1} + dis(HIGH_i, HIGH_j))
\end{cases}$

其中，$dis$表示两点间的距离，$LOW_i$表示第$i$个矩形和第$i+1$个矩形的交界线的最低点，$HIGH_i$表示第$i$个矩形和第$i+1$个矩形的交界线的最高点。

在状态转移过程中，需要判断转移是否可行，这可以通过斜率来判断$LOW_i$ 或$HIGH_i$与$LOW_j$或$HIGH_j$的连线是否会超出$i$和$j$之间的矩形，如果不会，则可以转移。
